#### ps

ps命令查看进程，可以看到有哪些进程正在运行，并且可以看到**进程的运行状态**、进程是否结束、**进程有没有僵死**、**哪些进程占用了过多的资源**。

ps显示瞬间进程的状态，并不动态连续，如果相对进程进行实时监控应该使用`top`命令

ps命令常用的选项参数有：

| 选项   | 功能                                           |
| ------ | ---------------------------------------------- |
| -A     | 显示所有的进程，跟-e的效果相同                 |
| **-a** | 显示现行终端机下的所有进程，包括其他用户的进程 |
| **-u** | 显示当前用户的进程状态                         |
| **-x** | 通常与 a 这个参数一起使用，可列出较完整信息    |
| **-l** | 较长、较详细的将该PID的信息列出                |
| -j     | 工作的格式(jobs format)                        |
| -f     | 把进程的所有信息都显示出来                     |
| -e     | 表示显示所有继承                               |

**ps使用实例**

**较详细的将本次登入用户的进程列出来**

```shell
ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1001 1702969 1702967  0  80   0 - 11484 -      pts/1    00:00:01 zsh
0 R  1001 1710433 1702969  0  80   0 -  7460 -      pts/1    00:00:00 ps
```

表头含义：

- F:内核分配给进程的系统标记
- S:进程的状态（O代表正待运行，S代表在休眠，R代表可运行正等待运行，Z代表僵化，进程结束但父进程已不存在；T代表停止）
- PID:进程的ID
- PPID：父进程的ID
- C:占CPU资源的百分比
- PRI：进程的优先级，越小越早被执行
- NI：代表进程的nice值，表示进程可被执行的优先级修正数值。
- ADDR:代表进程的地址，指出进程在内存的哪个部分，如果是正在运行的程序一般是`-`
- SZ：占用内存的大小
- WATCH：判断当前进程是否正在运行，若为`-`则代表正在运行，若进程处于休眠状态值为在内核中的地址
- TTY:该进程在哪个终端机上面运行若与终端机无关，则显示?，另外，tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。
- TIME:占用CPU的时间
- CMD:所下达的指令名称

**列出当前内存中的所有进程**

```shell
ps -aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.0 204676  7012 ?        Ss   Jul07   6:37 /sbin/init nokaslr
root           2  0.0  0.0      0     0 ?        S    Jul07   0:07 [kthreadd]
root           4  0.0  0.0      0     0 ?        I<   Jul07   0:00 [kworker/0:0H]
root           6  0.0  0.0      0     0 ?        I<   Jul07   0:00 [mm_percpu_wq]
root           7  0.0  0.0      0     0 ?        S    Jul07   7:03 [ksoftirqd/0]
root           8  0.0  0.0      0     0 ?        I    Jul07  54:18 [rcu_sched]
root           9  0.0  0.0      0     0 ?        I    Jul07   0:00 [rcu_bh]
......
```

- VSZ：该进程使用的虚拟内存量
- RSS：该进程占用的固定的内存量

ps -aux默认是无序的，可以通过`--sort`来排序，如：

```shell
ps -aux --sort -pcpu|less -N     #按照cpu占用来排序
ps -aux --sort -pmem|less -N     #按照内存占用来排序
```

**查看指定进程**

```shell
ps -ef | grep php #查看php
```



#### pstree

查看进程树

pstree [选项] [PID或用户名]

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 显示启动每个进程对应的完整指令，包括启动进程的路径、参数等。 |
| -c   | 不使用精简法显示进程信息，即显示的进程中包含子进程和父进程。 |
| -n   | 根据进程 PID 号来排序输出，默认是以程序名排序输出的。        |
| -p   | 显示进程的 PID。                                             |
| -u   | 显示进程对应的用户名称。                                     |

需要注意的是，在使用 pstree 命令时，如果不指定进程的 PID 号，也不指定用户名称，则会以 init 进程为根进程，显示系统中所有程序和进程的信息；反之，若指定 PID 号或用户名，则将以 PID 或指定命令为根进程，显示 PID 或用户对应的所有程序和进程。

init 进程是系统启动的第一个进程，进程的 PID 是 1，也是系统中所有进程的父进程。



#### netstat

显示网络状态信息

```
-a 显示所有连接和监听端口
-t (tcp)仅显示tcp相关选项
-u (udp)仅显示udp相关选项
-n 拒绝显示别名，能显示数字的全部转化成数字。
-p 显示建立相关链接的程序名
```



#### awk

用来处理文本，将文本按照指定的格式输出。

简单来说awk就是将文件逐行读入，以空格为默认分隔符将每行切片，切开的部分进行各种分析。

使用方法：

```shell
awk [-F field-separator] 'pattern + {action}' {filename}
```

[-F field-separator]是可选的，指定分割的标识，默认是空格。

`pattern`表示awk在数据中查找的内容，匹配规则是正则表达式。

`action`是在找到匹配内容是所执行的一系列命令。通常为设置变量，设置数组，数组循环，加减乘除操作，字符串拼接。	

awk内建变量：

FS：列分割符。指定每行文本的字段分隔符，默认为空格或制表位。与"-F"作用相同
NF：当前处理的行的字段个数。
NR：当前处理的行的行号（序数）。
$0：当前处理的行的整行内容。
$n：当前处理行的第n个字段（第n列）。
FILENAME：被处理的文件名。
RS：行分隔符。awk从文件上读取资料时,将根据RS的定义把读取的资料切割成许多条记录,而awk一次仅读入一条记录,以进行处理。预设值是’\n’

```shell
awk '{print}' name.txt				#输出所有内容
awk '{print $0}' name.txt			#输出所有内容

awk 'NR==1,NR==3 {print}' name.txt	#输出第 1~3 行内容
awk 'NR==1;NR==3 {print}' name.txt	#输出第 1和第3 行内容
awk '(NR>=1)&&(NR<=3) {print}' name.txt	#输出第 1~3 行内容
awk '(NR%2)==1{print}' name.txt 		#输出所有奇数行的内容
awk '(NR%2)==0{print}' name.txt		#输出所有偶数行的内容

awk '/^root/{print}' /etc/passwd		#输出以 root 开头的行
awk '/nologin$/{print}' /etc/passwd		#输出以 nologin 结尾的行

awk 'BEGIN {x=0};/\/bin\/bash$/{x++};END {print x}' /etc/passwd		#统计以/bin/bash 结尾的行数，等同于 grep -c "/bin/bash$" /etc/passwd
注意：BEGIN模式表示，在处理指定的文本之前，需要先执行BEGIN模式中指定的动作；awk再处理指定的文本，之后再执行END模式中指定的动作，END{}语句块中，往往会放入打印结果等语句

awk -F ":" '{print $1}' /etc/passwd 		#输出每行中(以空格或制表位分隔)的第3个字段
echo $PATH | awk 'BEGIN{RS=":"};END{print NR}'		#统计以冒号分隔的文本段落数，END{}语句块中，往往会放入打印结果等语句

```



#### sed

```shell
sed [选项] [脚本命令] 文件名
```

```txt
 -e ：直接在命令行模式上进行sed动作编辑，此为默认选项;
 
 -f ：将sed的动作写在一个文件内，用–f filename 执行filename内的sed动作;
 
 -i ：直接修改文件内容;
 
 -n ：只打印模式匹配的行；
 
 -r ：支持扩展表达式;
 
 -h或--help：显示帮助；
 
 -V或--version：显示版本信息。
```



**sed脚本命令**

`[address]s/pattern/replacement/flags`

其中，address标识指定要操作的具体行，pattern指的是要替换的内容，replacement指的是要替换的新内容。



#### grep

常用选项

**-c** 只输出匹配行的数量
**-i** 不区分大小写（只适用于单字符）
**-h** 查询多文件时不显示文件名
**-l** 查询多文件时只输出包含匹配字符的文件名
**-n** 显示匹配行及行号
**-s** 不显示不存在或无匹配文本的错误信息
**-v** 显示不包含匹配文本的所有行。

**-w**显示完全匹配的列

1. 在单个文件中查找字符串

```shell
grep "literal_string" filename
```

2. 在**多个文件**中查找指定字符串，`FILE_PATTERN` 表示文件通配符表示。比如当前目录下的所有文件 `./*`

```shell
grep "string" FILE_PATTERN
```

3. 查找的过程中**忽略大小写**

```
grep -i "string" FILE
```

4. 用正则表达式查找字符串

```shell
grep "REGEX" filename
```

- `?` 0到1次
- `*` 0到多次
- `+` 1到多次
- `{n}` 之匹配n次
- `{n,}` 最少n次
- `{,m}` 最多m次
- `{n,m}` 匹配最少n次，最多m次

5. 匹配完整的单词，而不是子串

```shell
grep -iw "is" demo_file # 只会完整的匹配is这个单词
```

6. 现在匹配字符串**前面/后面/前后两边**的字符串。(**A**fter/**B**efore/Around)。

```shell
grep -A 3 -i "example" demo_text # After 连着打印“example” 单词后的2行，共3行
grep -B 3 -i "example" demo_text # Before 连着打印“example” 单词前的2行，共3行
grep -C 3 -i "example" demo_text # Both 连着打印“example” 单词前后的2行，共5行
```

8. 取反搜索结果

```shell
grep -v "go" demo_text  # 显示哪些不包含 go 子串的行
```

9. 计算出命中匹配的**总行数**

```shell
grep -c "pattern" filename # 6
```

10. 使用 `-n` 显示匹配的字符串在**文件中的行数**。

```cpp
grep -n "go" demo_text
```









#### df

df查看磁盘空间的使用情况，默认以Kb为单位。

`df -B G`以GB为单位显示

`df -h`磁盘大小按照合适的单位展示

`df -H`使用1000进制



#### du

统计每个文件磁盘占用情况，会对目录进行递归运算，使用时需要指定文件

`du -h 文件`以合适的单位进行显示

`df -ah 文件`同时显示文件和子文件的大小

`df -h --time 文件`获取文件修改的时间







#### Linux目录结构

![image-20230625200323437](./assets/image-20230625200323437.png)

- bin (binaries)存放二进制可执行文件
- sbin (super user binaries)存放二进制可执行文件，只有root才能访问
- etc (etcetera)存放系统配置文件
- usr (unix shared resources)用于存放共享的系统资源
- home 存放用户文件的根目录
- root 超级用户目录
- dev (devices)用于存放设备文件
- lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块
- mnt (mount)系统管理员安装临时文件系统的安装点
- boot 存放用于系统引导时使用的各种文件
- tmp (temporary)用于存放各种临时文件
- var (variable)用于存放运行时需要改变数据的文件

#### Linux内核

Linxu内核组成

Linux内核主要由 **进程管理**、**内存管理**、**设备驱动**、**文件系统**、**网络协议栈** 外加一个 **系统调用**。



I/O机制

I/O设备又叫输入/输出设备，是人类与计算机进行通讯的外部硬件。输入/输出设备能够向计算机发送数据（输出），并从计算机接收数据（输入）。

I/O设备可以分为两种：**块设备(block devices)** 和 **字符设备(character devices)**

**块设备**

块设备是一个能够存储固定大小信息的设备，支持以固定大小的块，扇区或群集读取和写入设备。每个块都有自己的物理地址，通常块的大小在512-65536字节之间。所有传输的信息都会以连续的**块为单位**。块设备的基本特征是每个块都较为对立，能够独立的进行读写。

常见的块设备有 硬盘、蓝光光盘、USB盘。与字符设备相比，块设备通常需要较少的引脚。

块设备缺点：

基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要**读取**该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要**写入**块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。

**字符设备**

字符设备**以字符为单位**发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻址操作。

常见的字符设备有 打印机、网络设备、鼠标、以及大多数与磁盘不同的设备。



inode



#### 软连接和硬链接

链接简单说实际上时文件共享的方式。

硬链接：多个文件名指向同一索引节点(inode)。硬链接的作用时允许一个文件拥有多个有效路径。这样用户可以建立硬链接到重要文件，以防止误删。inode有多个硬链接，只删除一个不会影响inode本身和其他的链接。只有最后一个删除后，文件的数据块以及目录的链接才会被释放。（文件真正被删除的条件是所有的硬链接都被删除）

软连接：又称为符号链接，类似于windows的快捷方式。在软链接中，文件实际上是一个文本文件，其中包含另一文件的位置信息。在对软链接文件进行读写操作时，系统会自动把该操作转换为对源文件的操作。删除软链接时仅仅删除链接文件，不会删除源文件本身。



#### 常见面试指令

1. Linux如何查看一个进程的pid号
   - ps -aux | grep 进程名称
   - top | grep 进程名称
2. 
